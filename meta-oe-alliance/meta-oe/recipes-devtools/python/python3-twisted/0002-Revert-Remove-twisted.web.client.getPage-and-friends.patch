From d9735d617229263d3330ed29e82fe92b94368f97 Mon Sep 17 00:00:00 2001
From: NickerSK <nickersk@gmail.com>
Date: Sat, 19 Feb 2022 19:35:54 +0100
Subject: [PATCH] Revert "Remove twisted.web.client.getPage and friends"

This reverts commit a21a1efce87c77b4acf309db9445643c2a6d8162.

diff --git a/src/twisted/web/client.py b/src/twisted/web/client.py
index eb911ec53..433f4315f 100644
--- a/src/twisted/web/client.py
+++ b/src/twisted/web/client.py
@@ -27,10 +27,12 @@ from twisted.logger import Logger
 from twisted.python.compat import nativeString, networkString
 from twisted.python.components import proxyForInterface
 from twisted.python.deprecate import (
+    deprecated,
     deprecatedModuleAttribute,
     getDeprecationWarningString,
 )
 from twisted.python.failure import Failure
+from twisted.python.util import InsensitiveDict
 from twisted.web import error, http
 from twisted.web._newclient import _ensureValidMethod, _ensureValidURI
 from twisted.web.http_headers import Headers
@@ -57,6 +59,552 @@ class PartialDownloadError(error.Error):
     """
 
 
+class HTTPPageGetter(http.HTTPClient):
+    """
+    Gets a resource via HTTP, then quits.
+
+    Typically used with L{HTTPClientFactory}.  Note that this class does not, by
+    itself, do anything with the response.  If you want to download a resource
+    into a file, use L{HTTPPageDownloader} instead.
+
+    @ivar _completelyDone: A boolean indicating whether any further requests are
+        necessary after this one completes in order to provide a result to
+        C{self.factory.deferred}.  If it is C{False}, then a redirect is going
+        to be followed.  Otherwise, this protocol's connection is the last one
+        before firing the result Deferred.  This is used to make sure the result
+        Deferred is only fired after the connection is cleaned up.
+    """
+
+    quietLoss = 0
+    followRedirect = True
+    failed = 0
+
+    _completelyDone = True
+
+    _specialHeaders = {b"host", b"user-agent", b"cookie", b"content-length"}
+
+    def connectionMade(self):
+        method = _ensureValidMethod(getattr(self.factory, "method", b"GET"))
+        self.sendCommand(method, _ensureValidURI(self.factory.path))
+        if self.factory.scheme == b"http" and self.factory.port != 80:
+            host = b"%b:%d" % (self.factory.host, self.factory.port)
+        elif self.factory.scheme == b"https" and self.factory.port != 443:
+            host = b"%b:%d" % (self.factory.host, self.factory.port)
+        else:
+            host = self.factory.host
+        self.sendHeader(b"Host", self.factory.headers.get(b"host", host))
+        self.sendHeader(b"User-Agent", self.factory.agent)
+        data = getattr(self.factory, "postdata", None)
+        if data is not None:
+            self.sendHeader(b"Content-Length", b"%d" % (len(data),))
+
+        cookieData = []
+        for (key, value) in self.factory.headers.items():
+            if key.lower() not in self._specialHeaders:
+                # we calculated it on our own
+                self.sendHeader(key, value)
+            if key.lower() == b"cookie":
+                cookieData.append(value)
+        for cookie, cookval in self.factory.cookies.items():
+            cookieData.append(cookie + b"=" + cookval)
+        if cookieData:
+            self.sendHeader(b"Cookie", b"; ".join(cookieData))
+        self.endHeaders()
+        self.headers = {}
+
+        if data is not None:
+            self.transport.write(data)
+
+    def handleHeader(self, key, value):
+        """
+        Called every time a header is received. Stores the header information
+        as key-value pairs in the C{headers} attribute.
+
+        @type key: C{str}
+        @param key: An HTTP header field name.
+
+        @type value: C{str}
+        @param value: An HTTP header field value.
+        """
+        key = key.lower()
+        l = self.headers.setdefault(key, [])
+        l.append(value)
+
+    def handleStatus(self, version, status, message):
+        """
+        Handle the HTTP status line.
+
+        @param version: The HTTP version.
+        @type version: L{bytes}
+        @param status: The HTTP status code, an integer represented as a
+            bytestring.
+        @type status: L{bytes}
+        @param message: The HTTP status message.
+        @type message: L{bytes}
+        """
+        self.version, self.status, self.message = version, status, message
+        self.factory.gotStatus(version, status, message)
+
+    def handleEndHeaders(self):
+        self.factory.gotHeaders(self.headers)
+        m = getattr(
+            self, "handleStatus_" + nativeString(self.status), self.handleStatusDefault
+        )
+        m()
+
+    def handleStatus_200(self):
+        pass
+
+    handleStatus_201 = lambda self: self.handleStatus_200()
+    handleStatus_202 = lambda self: self.handleStatus_200()
+
+    def handleStatusDefault(self):
+        self.failed = 1
+
+    def handleStatus_301(self):
+        l = self.headers.get(b"location")
+        if not l:
+            self.handleStatusDefault()
+            return
+        url = l[0]
+        if self.followRedirect:
+            self.factory._redirectCount += 1
+            if self.factory._redirectCount >= self.factory.redirectLimit:
+                err = error.InfiniteRedirection(
+                    self.status, b"Infinite redirection detected", location=url
+                )
+                self.factory.noPage(Failure(err))
+                self.quietLoss = True
+                self.transport.loseConnection()
+                return
+
+            self._completelyDone = False
+            self.factory.setURL(url)
+
+            from twisted.internet import reactor
+
+            if self.factory.scheme == b"https":
+                from twisted.internet import ssl
+
+                contextFactory = ssl.ClientContextFactory()
+                reactor.connectSSL(
+                    nativeString(self.factory.host),
+                    self.factory.port,
+                    self.factory,
+                    contextFactory,
+                )
+            else:
+                reactor.connectTCP(
+                    nativeString(self.factory.host), self.factory.port, self.factory
+                )
+        else:
+            self.handleStatusDefault()
+            self.factory.noPage(
+                Failure(error.PageRedirect(self.status, self.message, location=url))
+            )
+        self.quietLoss = True
+        self.transport.loseConnection()
+
+    def handleStatus_302(self):
+        if self.afterFoundGet:
+            self.handleStatus_303()
+        else:
+            self.handleStatus_301()
+
+    def handleStatus_303(self):
+        self.factory.method = b"GET"
+        self.handleStatus_301()
+
+    def connectionLost(self, reason):
+        """
+        When the connection used to issue the HTTP request is closed, notify the
+        factory if we have not already, so it can produce a result.
+        """
+        if not self.quietLoss:
+            http.HTTPClient.connectionLost(self, reason)
+            self.factory.noPage(reason)
+        if self._completelyDone:
+            # Only if we think we're completely done do we tell the factory that
+            # we're "disconnected".  This way when we're following redirects,
+            # only the last protocol used will fire the _disconnectedDeferred.
+            self.factory._disconnectedDeferred.callback(None)
+
+    def handleResponse(self, response):
+        if self.quietLoss:
+            return
+        if self.failed:
+            self.factory.noPage(
+                Failure(error.Error(self.status, self.message, response))
+            )
+        if self.factory.method == b"HEAD":
+            # Callback with empty string, since there is never a response
+            # body for HEAD requests.
+            self.factory.page(b"")
+        elif self.length != None and self.length != 0:
+            self.factory.noPage(
+                Failure(PartialDownloadError(self.status, self.message, response))
+            )
+        else:
+            self.factory.page(response)
+        # server might be stupid and not close connection. admittedly
+        # the fact we do only one request per connection is also
+        # stupid...
+        self.transport.loseConnection()
+
+    def timeout(self):
+        self.quietLoss = True
+        self.transport.abortConnection()
+        self.factory.noPage(
+            defer.TimeoutError(
+                "Getting %s took longer than %s seconds."
+                % (self.factory.url, self.factory.timeout)
+            )
+        )
+
+
+class HTTPPageDownloader(HTTPPageGetter):
+
+    transmittingPage = 0
+
+    def handleStatus_200(self, partialContent=0):
+        HTTPPageGetter.handleStatus_200(self)
+        self.transmittingPage = 1
+        self.factory.pageStart(partialContent)
+
+    def handleStatus_206(self):
+        self.handleStatus_200(partialContent=1)
+
+    def handleResponsePart(self, data):
+        if self.transmittingPage:
+            self.factory.pagePart(data)
+
+    def handleResponseEnd(self):
+        if self.length:
+            self.transmittingPage = 0
+            self.factory.noPage(Failure(PartialDownloadError(self.status)))
+        if self.transmittingPage:
+            self.factory.pageEnd()
+            self.transmittingPage = 0
+        if self.failed:
+            self.factory.noPage(Failure(error.Error(self.status, self.message, None)))
+            self.transport.loseConnection()
+
+
+class HTTPClientFactory(protocol.ClientFactory):
+    """Download a given URL.
+
+    @type deferred: Deferred
+    @ivar deferred: A Deferred that will fire when the content has
+          been retrieved. Once this is fired, the ivars `status', `version',
+          and `message' will be set.
+
+    @type status: bytes
+    @ivar status: The status of the response.
+
+    @type version: bytes
+    @ivar version: The version of the response.
+
+    @type message: bytes
+    @ivar message: The text message returned with the status.
+
+    @type response_headers: dict
+    @ivar response_headers: The headers that were specified in the
+          response from the server.
+
+    @type method: bytes
+    @ivar method: The HTTP method to use in the request.  This should be one of
+        OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, or CONNECT (case
+        matters).  Other values may be specified if the server being contacted
+        supports them.
+
+    @type redirectLimit: int
+    @ivar redirectLimit: The maximum number of HTTP redirects that can occur
+          before it is assumed that the redirection is endless.
+
+    @type afterFoundGet: C{bool}
+    @ivar afterFoundGet: Deviate from the HTTP 1.1 RFC by handling redirects
+        the same way as most web browsers; if the request method is POST and a
+        302 status is encountered, the redirect is followed with a GET method
+
+    @type _redirectCount: int
+    @ivar _redirectCount: The current number of HTTP redirects encountered.
+
+    @ivar _disconnectedDeferred: A L{Deferred} which only fires after the last
+        connection associated with the request (redirects may cause multiple
+        connections to be required) has closed.  The result Deferred will only
+        fire after this Deferred, so that callers can be assured that there are
+        no more event sources in the reactor once they get the result.
+    """
+
+    protocol = HTTPPageGetter
+
+    url = None
+    scheme = None
+    host = b""
+    port = None
+    path = None
+
+    def __init__(
+        self,
+        url,
+        method=b"GET",
+        postdata=None,
+        headers=None,
+        agent=b"Twisted PageGetter",
+        timeout=0,
+        cookies=None,
+        followRedirect=True,
+        redirectLimit=20,
+        afterFoundGet=False,
+    ):
+        self.followRedirect = followRedirect
+        self.redirectLimit = redirectLimit
+        self._redirectCount = 0
+        self.timeout = timeout
+        self.agent = agent
+        self.afterFoundGet = afterFoundGet
+        if cookies is None:
+            cookies = {}
+        self.cookies = cookies
+        if headers is not None:
+            self.headers = InsensitiveDict(headers)
+        else:
+            self.headers = InsensitiveDict()
+        if postdata is not None:
+            self.headers.setdefault(b"Content-Length", b"%d" % (len(postdata),))
+            # just in case a broken http/1.1 decides to keep connection alive
+            self.headers.setdefault(b"connection", b"close")
+        self.postdata = postdata
+        self.method = _ensureValidMethod(method)
+
+        self.setURL(url)
+
+        self.waiting = 1
+        self._disconnectedDeferred = defer.Deferred()
+        self.deferred = defer.Deferred()
+        # Make sure the first callback on the result Deferred pauses the
+        # callback chain until the request connection is closed.
+        self.deferred.addBoth(self._waitForDisconnect)
+        self.response_headers = None
+
+    def _waitForDisconnect(self, passthrough):
+        """
+        Chain onto the _disconnectedDeferred, preserving C{passthrough}, so that
+        the result is only available after the associated connection has been
+        closed.
+        """
+        self._disconnectedDeferred.addCallback(lambda ignored: passthrough)
+        return self._disconnectedDeferred
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__}: {self.url}>"
+
+    def setURL(self, url):
+        _ensureValidURI(url.strip())
+        self.url = url
+        uri = URI.fromBytes(url)
+        if uri.scheme and uri.host:
+            self.scheme = uri.scheme
+            self.host = uri.host
+            self.port = uri.port
+        self.path = uri.originForm
+
+    def buildProtocol(self, addr):
+        p = protocol.ClientFactory.buildProtocol(self, addr)
+        p.followRedirect = self.followRedirect
+        p.afterFoundGet = self.afterFoundGet
+        if self.timeout:
+            from twisted.internet import reactor
+
+            timeoutCall = reactor.callLater(self.timeout, p.timeout)
+            self.deferred.addBoth(self._cancelTimeout, timeoutCall)
+        return p
+
+    def _cancelTimeout(self, result, timeoutCall):
+        if timeoutCall.active():
+            timeoutCall.cancel()
+        return result
+
+    def gotHeaders(self, headers):
+        """
+        Parse the response HTTP headers.
+
+        @param headers: The response HTTP headers.
+        @type headers: L{dict}
+        """
+        self.response_headers = headers
+        if b"set-cookie" in headers:
+            for cookie in headers[b"set-cookie"]:
+                if b"=" in cookie:
+                    cookparts = cookie.split(b";")
+                    cook = cookparts[0]
+                    cook.lstrip()
+                    k, v = cook.split(b"=", 1)
+                    self.cookies[k.lstrip()] = v.lstrip()
+
+    def gotStatus(self, version, status, message):
+        """
+        Set the status of the request on us.
+
+        @param version: The HTTP version.
+        @type version: L{bytes}
+        @param status: The HTTP status code, an integer represented as a
+            bytestring.
+        @type status: L{bytes}
+        @param message: The HTTP status message.
+        @type message: L{bytes}
+        """
+        self.version, self.status, self.message = version, status, message
+
+    def page(self, page):
+        if self.waiting:
+            self.waiting = 0
+            self.deferred.callback(page)
+
+    def noPage(self, reason):
+        if self.waiting:
+            self.waiting = 0
+            self.deferred.errback(reason)
+
+    def clientConnectionFailed(self, _, reason):
+        """
+        When a connection attempt fails, the request cannot be issued.  If no
+        result has yet been provided to the result Deferred, provide the
+        connection failure reason as an error result.
+        """
+        if self.waiting:
+            self.waiting = 0
+            # If the connection attempt failed, there is nothing more to
+            # disconnect, so just fire that Deferred now.
+            self._disconnectedDeferred.callback(None)
+            self.deferred.errback(reason)
+
+
+class HTTPDownloader(HTTPClientFactory):
+    """
+    Download to a file.
+    """
+
+    protocol = HTTPPageDownloader
+    value = None
+    _log = Logger()
+
+    def __init__(
+        self,
+        url,
+        fileOrName,
+        method=b"GET",
+        postdata=None,
+        headers=None,
+        agent=b"Twisted client",
+        supportPartial=False,
+        timeout=0,
+        cookies=None,
+        followRedirect=True,
+        redirectLimit=20,
+        afterFoundGet=False,
+    ):
+        self.requestedPartial = 0
+        if isinstance(fileOrName, str):
+            self.fileName = fileOrName
+            self.file = None
+            if supportPartial and os.path.exists(self.fileName):
+                fileLength = os.path.getsize(self.fileName)
+                if fileLength:
+                    self.requestedPartial = fileLength
+                    if headers is None:
+                        headers = {}
+                    headers[b"range"] = b"bytes=%d-" % (fileLength,)
+        else:
+            self.file = fileOrName
+        HTTPClientFactory.__init__(
+            self,
+            url,
+            method=method,
+            postdata=postdata,
+            headers=headers,
+            agent=agent,
+            timeout=timeout,
+            cookies=cookies,
+            followRedirect=followRedirect,
+            redirectLimit=redirectLimit,
+            afterFoundGet=afterFoundGet,
+        )
+
+    def gotHeaders(self, headers):
+        HTTPClientFactory.gotHeaders(self, headers)
+        if self.requestedPartial:
+            contentRange = headers.get(b"content-range", None)
+            if not contentRange:
+                # server doesn't support partial requests, oh well
+                self.requestedPartial = 0
+                return
+            start, end, realLength = http.parseContentRange(contentRange[0])
+            if start != self.requestedPartial:
+                # server is acting weirdly
+                self.requestedPartial = 0
+
+    def openFile(self, partialContent):
+        if partialContent:
+            file = open(self.fileName, "rb+")
+            file.seek(0, 2)
+        else:
+            file = open(self.fileName, "wb")
+        return file
+
+    def pageStart(self, partialContent):
+        """Called on page download start.
+
+        @param partialContent: tells us if the download is partial download we requested.
+        """
+        if partialContent and not self.requestedPartial:
+            raise ValueError(
+                "we shouldn't get partial content response if we didn't want it!"
+            )
+        if self.waiting:
+            try:
+                if not self.file:
+                    self.file = self.openFile(partialContent)
+            except OSError:
+                # raise
+                self.deferred.errback(Failure())
+
+    def pagePart(self, data):
+        if not self.file:
+            return
+        try:
+            self.file.write(data)
+        except OSError:
+            # raise
+            self.file = None
+            self.deferred.errback(Failure())
+
+    def noPage(self, reason):
+        """
+        Close the storage file and errback the waiting L{Deferred} with the
+        given reason.
+        """
+        if self.waiting:
+            self.waiting = 0
+            if self.file:
+                try:
+                    self.file.close()
+                except BaseException:
+                    self._log.failure("Error closing HTTPDownloader file")
+            self.deferred.errback(reason)
+
+    def pageEnd(self):
+        self.waiting = 0
+        if not self.file:
+            return
+        try:
+            self.file.close()
+        except OSError:
+            self.deferred.errback(Failure())
+            return
+        self.deferred.callback(self.value)
+
+
 class URI:
     """
     A URI object.
@@ -229,6 +777,65 @@ def _makeGetterFactory(url, factoryFactory, contextFactory=None, *args, **kwargs
     return factory
 
 
+_GETPAGE_REPLACEMENT_TEXT = "https://pypi.org/project/treq/ or twisted.web.client.Agent"
+
+
+def _deprecateGetPageClasses():
+    """
+    Mark the protocols and factories associated with L{getPage} and
+    L{downloadPage} as deprecated.
+    """
+    for klass in [
+        HTTPPageGetter,
+        HTTPPageDownloader,
+        HTTPClientFactory,
+        HTTPDownloader,
+    ]:
+        deprecatedModuleAttribute(
+            Version("Twisted", 16, 7, 0),
+            getDeprecationWarningString(
+                klass,
+                Version("Twisted", 16, 7, 0),
+                replacement=_GETPAGE_REPLACEMENT_TEXT,
+            ).split("; ")[1],
+            klass.__module__,
+            klass.__name__,
+        )
+
+
+_deprecateGetPageClasses()
+
+
+@deprecated(Version("Twisted", 16, 7, 0), _GETPAGE_REPLACEMENT_TEXT)
+def getPage(url, contextFactory=None, *args, **kwargs):
+    """
+    Download a web page as a string.
+
+    Download a page. Return a deferred, which will callback with a
+    page (as a string) or errback with a description of the error.
+
+    See L{HTTPClientFactory} to see what extra arguments can be passed.
+    """
+    return _makeGetterFactory(
+        url, HTTPClientFactory, contextFactory=contextFactory, *args, **kwargs
+    ).deferred
+
+
+@deprecated(Version("Twisted", 16, 7, 0), _GETPAGE_REPLACEMENT_TEXT)
+def downloadPage(url, file, contextFactory=None, *args, **kwargs):
+    """
+    Download a web page to a file.
+
+    @param file: path to file on filesystem, or file-like object.
+
+    See HTTPDownloader to see what extra args can be passed.
+    """
+    factoryFactory = lambda url, *a, **kw: HTTPDownloader(url, file, *a, **kw)
+    return _makeGetterFactory(
+        url, factoryFactory, contextFactory=contextFactory, *args, **kwargs
+    ).deferred
+
+
 # The code which follows is based on the new HTTP client implementation.  It
 # should be significantly better than anything above, though it is not yet
 # feature equivalent.
@@ -1773,8 +2380,14 @@ __all__ = [
     "BrowserLikeRedirectAgent",
     "ContentDecoderAgent",
     "CookieAgent",
+    "downloadPage",
+    "getPage",
     "GzipDecoder",
+    "HTTPClientFactory",
     "HTTPConnectionPool",
+    "HTTPDownloader",
+    "HTTPPageDownloader",
+    "HTTPPageGetter",
     "PartialDownloadError",
     "ProxyAgent",
     "readBody",
diff --git a/src/twisted/web/test/test_webclient.py b/src/twisted/web/test/test_webclient.py
index 4237598c1..224a822e6 100644
--- a/src/twisted/web/test/test_webclient.py
+++ b/src/twisted/web/test/test_webclient.py
@@ -2,14 +2,218 @@
 # See LICENSE for details.
 
 """
-Tests L{twisted.web.client} helper APIs
+Tests for the old L{twisted.web.client} APIs, C{getPage} and friends.
 """
 
 
-from urllib.parse import urlparse
+import io
+import os
+from errno import ENOSPC
+from urllib.parse import urljoin, urlparse
 
-from twisted.trial import unittest
-from twisted.web import client
+from twisted import test
+from twisted.internet import address, defer, interfaces, reactor
+from twisted.internet.protocol import ClientFactory
+from twisted.logger import (
+    FilteringLogObserver,
+    Logger,
+    LogLevel,
+    LogLevelFilterPredicate,
+    globalLogPublisher,
+)
+from twisted.protocols.policies import WrappingFactory
+from twisted.python.compat import nativeString, networkString
+from twisted.python.filepath import FilePath
+from twisted.python.reflect import requireModule
+from twisted.test.proto_helpers import (
+    EventLoggingObserver,
+    StringTransport,
+    waitUntilAllDisconnected,
+)
+from twisted.trial import unittest, util
+from twisted.web import client, error, resource, server
+from twisted.web.static import Data
+from twisted.web.test.injectionhelpers import (
+    MethodInjectionTestsMixin,
+    URIInjectionTestsMixin,
+)
+from twisted.web.util import Redirect
+
+ssl = requireModule("twisted.internet.ssl")
+
+serverPEM = FilePath(test.__file__).sibling("server.pem")
+serverPEMPath = serverPEM.asBytesMode().path
+
+
+class ExtendedRedirect(resource.Resource):
+    """
+    Redirection resource.
+
+    The HTTP status code is set according to the C{code} query parameter.
+
+    @type lastMethod: C{bytes}
+    @ivar lastMethod: Last handled HTTP request method
+    """
+
+    isLeaf = True
+    lastMethod = None
+
+    def __init__(self, url):
+        resource.Resource.__init__(self)
+        self.url = url
+
+    def render(self, request):
+        if self.lastMethod:
+            self.lastMethod = request.method
+            return b"OK Thnx!"
+        else:
+            self.lastMethod = request.method
+            code = int(request.args[b"code"][0])
+            return self.redirectTo(self.url, request, code)
+
+    def getChild(self, name, request):
+        return self
+
+    def redirectTo(self, url, request, code):
+        request.setResponseCode(code)
+        request.setHeader(b"location", url)
+        return b"OK Bye!"
+
+
+class ForeverTakingResource(resource.Resource):
+    """
+    L{ForeverTakingResource} is a resource which never finishes responding
+    to requests.
+    """
+
+    def __init__(self, write=False):
+        resource.Resource.__init__(self)
+        self._write = write
+
+    def render(self, request):
+        if self._write:
+            request.write(b"some bytes")
+        return server.NOT_DONE_YET
+
+
+class ForeverTakingNoReadingResource(resource.Resource):
+    """
+    L{ForeverTakingNoReadingResource} is a resource that never finishes
+    responding and that removes itself from the read loop.
+    """
+
+    def __init__(self):
+        resource.Resource.__init__(self)
+
+    def render(self, request):
+        # Stop the producing.
+        request.transport.pauseProducing()
+        return server.NOT_DONE_YET
+
+
+class CookieMirrorResource(resource.Resource):
+    def render(self, request):
+        l = []
+        for k, v in sorted(list(request.received_cookies.items())):
+            l.append((nativeString(k), nativeString(v)))
+        l.sort()
+        return networkString(repr(l))
+
+
+class RawCookieMirrorResource(resource.Resource):
+    def render(self, request):
+        header = request.getHeader(b"cookie")
+        if header is None:
+            return b"None"
+        return networkString(repr(nativeString(header)))
+
+
+class ErrorResource(resource.Resource):
+    def render(self, request):
+        request.setResponseCode(401)
+        if request.args.get(b"showlength"):
+            request.setHeader(b"content-length", b"0")
+        return b""
+
+
+class NoLengthResource(resource.Resource):
+    def render(self, request):
+        return b"nolength"
+
+
+class HostHeaderResource(resource.Resource):
+    """
+    A testing resource which renders itself as the value of the host header
+    from the request.
+    """
+
+    def render(self, request):
+        return request.requestHeaders.getRawHeaders(b"host")[0]
+
+
+class PayloadResource(resource.Resource):
+    """
+    A testing resource which renders itself as the contents of the request body
+    as long as the request body is 100 bytes long, otherwise which renders
+    itself as C{"ERROR"}.
+    """
+
+    def render(self, request):
+        data = request.content.read()
+        contentLength = request.requestHeaders.getRawHeaders(b"content-length")[0]
+        if len(data) != 100 or int(contentLength) != 100:
+            return b"ERROR"
+        return data
+
+
+class DelayResource(resource.Resource):
+    def __init__(self, seconds):
+        self.seconds = seconds
+
+    def render(self, request):
+        def response():
+            request.write(b"some bytes")
+            request.finish()
+
+        reactor.callLater(self.seconds, response)
+        return server.NOT_DONE_YET
+
+
+class BrokenDownloadResource(resource.Resource):
+    def render(self, request):
+        # only sends 3 bytes even though it claims to send 5
+        request.setHeader(b"content-length", b"5")
+        request.write(b"abc")
+        return b""
+
+
+class CountingRedirect(Redirect):
+    """
+    A L{Redirect} resource that keeps track of the number of times the
+    resource has been accessed.
+    """
+
+    def __init__(self, *a, **kw):
+        Redirect.__init__(self, *a, **kw)
+        self.count = 0
+
+    def render(self, request):
+        self.count += 1
+        return Redirect.render(self, request)
+
+
+class CountingResource(resource.Resource):
+    """
+    A resource that keeps track of the number of times it has been accessed.
+    """
+
+    def __init__(self):
+        resource.Resource.__init__(self)
+        self.count = 0
+
+    def render(self, request):
+        self.count += 1
+        return b"Success"
 
 
 class URLJoinTests(unittest.TestCase):
@@ -55,6 +259,853 @@ class URLJoinTests(unittest.TestCase):
         )
 
 
+class HTTPPageGetterTests(unittest.TestCase):
+    """
+    Tests for L{HTTPPagerGetter}, the HTTP client protocol implementation
+    used to implement L{getPage}.
+    """
+
+    suppress = [util.suppress(category=DeprecationWarning)]
+
+    def test_earlyHeaders(self):
+        """
+        When a connection is made, L{HTTPPagerGetter} sends the headers from
+        its factory's C{headers} dict.  If I{Host} or I{Content-Length} is
+        present in this dict, the values are not sent, since they are sent with
+        special values before the C{headers} dict is processed.  If
+        I{User-Agent} is present in the dict, it overrides the value of the
+        C{agent} attribute of the factory.  If I{Cookie} is present in the
+        dict, its value is added to the values from the factory's C{cookies}
+        attribute.
+        """
+        factory = client.HTTPClientFactory(
+            b"http://foo/bar",
+            agent=b"foobar",
+            cookies={b"baz": b"quux"},
+            postdata=b"some data",
+            headers={
+                b"Host": b"example.net",
+                b"User-Agent": b"fooble",
+                b"Cookie": b"blah blah",
+                b"Content-Length": b"12981",
+                b"Useful": b"value",
+            },
+        )
+        transport = StringTransport()
+        protocol = client.HTTPPageGetter()
+        protocol.factory = factory
+        protocol.makeConnection(transport)
+        result = transport.value()
+        for expectedHeader in [
+            b"Host: example.net\r\n",
+            b"User-Agent: foobar\r\n",
+            b"Content-Length: 9\r\n",
+            b"Useful: value\r\n",
+            b"connection: close\r\n",
+            b"Cookie: blah blah; baz=quux\r\n",
+        ]:
+            self.assertIn(expectedHeader, result)
+
+
+class WebClientTests(unittest.TestCase):
+    suppress = [util.suppress(category=DeprecationWarning)]
+    _log = Logger()
+
+    def _listen(self, site):
+        return reactor.listenTCP(0, site, interface="127.0.0.1")
+
+    def setUp(self):
+        self.agent = None  # for twisted.web.client.Agent test
+        self.cleanupServerConnections = 0
+        r = resource.Resource()
+        r.putChild(b"file", Data(b"0123456789", "text/html"))
+        r.putChild(b"redirect", Redirect(b"/file"))
+        self.infiniteRedirectResource = CountingRedirect(b"/infiniteRedirect")
+        r.putChild(b"infiniteRedirect", self.infiniteRedirectResource)
+        r.putChild(b"wait", ForeverTakingResource())
+        r.putChild(b"write-then-wait", ForeverTakingResource(write=True))
+        r.putChild(b"never-read", ForeverTakingNoReadingResource())
+        r.putChild(b"error", ErrorResource())
+        r.putChild(b"nolength", NoLengthResource())
+        r.putChild(b"host", HostHeaderResource())
+        r.putChild(b"payload", PayloadResource())
+        r.putChild(b"broken", BrokenDownloadResource())
+        r.putChild(b"cookiemirror", CookieMirrorResource())
+        r.putChild(b"delay1", DelayResource(1))
+        r.putChild(b"delay2", DelayResource(2))
+
+        self.afterFoundGetCounter = CountingResource()
+        r.putChild(b"afterFoundGetCounter", self.afterFoundGetCounter)
+        r.putChild(b"afterFoundGetRedirect", Redirect(b"/afterFoundGetCounter"))
+
+        miscasedHead = Data(b"miscased-head GET response content", "major/minor")
+        miscasedHead.render_Head = lambda request: b"miscased-head content"
+        r.putChild(b"miscased-head", miscasedHead)
+
+        self.extendedRedirect = ExtendedRedirect(b"/extendedRedirect")
+        r.putChild(b"extendedRedirect", self.extendedRedirect)
+        self.site = server.Site(r, timeout=None)
+        self.wrapper = WrappingFactory(self.site)
+        self.port = self._listen(self.wrapper)
+        self.portno = self.port.getHost().port
+
+    def tearDown(self):
+        if self.agent:
+            # clean up connections for twisted.web.client.Agent test.
+            self.agent.closeCachedConnections()
+            self.agent = None
+
+        # If the test indicated it might leave some server-side connections
+        # around, clean them up.
+        connections = list(self.wrapper.protocols.keys())
+        # If there are fewer server-side connections than requested,
+        # that's okay.  Some might have noticed that the client closed
+        # the connection and cleaned up after themselves.
+        for n in range(min(len(connections), self.cleanupServerConnections)):
+            proto = connections.pop()
+            self._log.info("Closing {proto}", proto=proto)
+            proto.transport.abortConnection()
+        d = self.port.stopListening()
+
+        return defer.DeferredList(
+            [waitUntilAllDisconnected(reactor, list(self.wrapper.protocols.keys())), d]
+        )
+
+    def getURL(self, path):
+        host = "http://127.0.0.1:%d/" % self.portno
+        return networkString(urljoin(host, nativeString(path)))
+
+    def testPayload(self):
+        s = b"0123456789" * 10
+        return client.getPage(self.getURL("payload"), postdata=s).addCallback(
+            self.assertEqual, s
+        )
+
+    def test_getPageBrokenDownload(self):
+        """
+        If the connection is closed before the number of bytes indicated by
+        I{Content-Length} have been received, the L{Deferred} returned by
+        L{getPage} fails with L{PartialDownloadError}.
+        """
+        d = client.getPage(self.getURL("broken"))
+        d = self.assertFailure(d, client.PartialDownloadError)
+        d.addCallback(lambda exc: self.assertEqual(exc.response, b"abc"))
+        return d
+
+    def test_downloadPageBrokenDownload(self):
+        """
+        If the connection is closed before the number of bytes indicated by
+        I{Content-Length} have been received, the L{Deferred} returned by
+        L{downloadPage} fails with L{PartialDownloadError}.
+        """
+        # test what happens when download gets disconnected in the middle
+        path = FilePath(self.mktemp())
+        d = client.downloadPage(self.getURL("broken"), path.path)
+        d = self.assertFailure(d, client.PartialDownloadError)
+
+        def checkResponse(response):
+            """
+            The HTTP status code from the server is propagated through the
+            C{PartialDownloadError}.
+            """
+            self.assertEqual(response.status, b"200")
+            self.assertEqual(response.message, b"OK")
+            return response
+
+        d.addCallback(checkResponse)
+
+        def cbFailed(ignored):
+            self.assertEqual(path.getContent(), b"abc")
+
+        d.addCallback(cbFailed)
+        return d
+
+    def test_downloadPageLogsFileCloseError(self):
+        """
+        If there is an exception closing the file being written to after the
+        connection is prematurely closed, that exception is logged.
+        """
+        exc = IOError(ENOSPC, "No file left on device")
+
+        class BrokenFile:
+            def write(self, bytes):
+                pass
+
+            def close(self):
+                raise exc
+
+        logObserver = EventLoggingObserver()
+        filtered = FilteringLogObserver(
+            logObserver, [LogLevelFilterPredicate(defaultLogLevel=LogLevel.critical)]
+        )
+        globalLogPublisher.addObserver(filtered)
+        self.addCleanup(lambda: globalLogPublisher.removeObserver(filtered))
+
+        d = client.downloadPage(self.getURL("broken"), BrokenFile())
+        d = self.assertFailure(d, client.PartialDownloadError)
+
+        def cbFailed(ignored):
+            self.assertEquals(1, len(logObserver))
+            event = logObserver[0]
+            f = event["log_failure"]
+            self.assertIsInstance(f.value, IOError)
+            self.assertEquals(f.value.args, exc.args)
+            self.assertEqual(len(self.flushLoggedErrors(IOError)), 1)
+
+        d.addCallback(cbFailed)
+        return d
+
+    def testHostHeader(self):
+        # if we pass Host header explicitly, it should be used, otherwise
+        # it should extract from url
+        return defer.gatherResults(
+            [
+                client.getPage(self.getURL("host")).addCallback(
+                    self.assertEqual, b"127.0.0.1:%d" % (self.portno,)
+                ),
+                client.getPage(
+                    self.getURL("host"), headers={b"Host": b"www.example.com"}
+                ).addCallback(self.assertEqual, b"www.example.com"),
+            ]
+        )
+
+    def test_getPage(self):
+        """
+        L{client.getPage} returns a L{Deferred} which is called back with
+        the body of the response if the default method B{GET} is used.
+        """
+        d = client.getPage(self.getURL("file"))
+        d.addCallback(self.assertEqual, b"0123456789")
+        return d
+
+    def test_getPageHEAD(self):
+        """
+        L{client.getPage} returns a L{Deferred} which is called back with
+        the empty string if the method is I{HEAD} and there is a successful
+        response code.
+        """
+        d = client.getPage(self.getURL("file"), method=b"HEAD")
+        d.addCallback(self.assertEqual, b"")
+        return d
+
+    def test_getPageNotQuiteHEAD(self):
+        """
+        If the request method is a different casing of I{HEAD} (ie, not all
+        capitalized) then it is not a I{HEAD} request and the response body
+        is returned.
+        """
+        d = client.getPage(self.getURL("miscased-head"), method=b"Head")
+        d.addCallback(self.assertEqual, b"miscased-head content")
+        return d
+
+    def test_timeoutNotTriggering(self):
+        """
+        When a non-zero timeout is passed to L{getPage} and the page is
+        retrieved before the timeout period elapses, the L{Deferred} is
+        called back with the contents of the page.
+        """
+        d = client.getPage(self.getURL("host"), timeout=100)
+        d.addCallback(self.assertEqual, networkString(f"127.0.0.1:{self.portno}"))
+        return d
+
+    def test_timeoutTriggering(self):
+        """
+        When a non-zero timeout is passed to L{getPage} and that many
+        seconds elapse before the server responds to the request. the
+        L{Deferred} is errbacked with a L{error.TimeoutError}.
+        """
+        # This will probably leave some connections around.
+        self.cleanupServerConnections = 1
+        return self.assertFailure(
+            client.getPage(self.getURL("wait"), timeout=0.000001), defer.TimeoutError
+        )
+
+    def testDownloadPage(self):
+        downloads = []
+        downloadData = [
+            ("file", self.mktemp(), b"0123456789"),
+            ("nolength", self.mktemp(), b"nolength"),
+        ]
+
+        for (url, name, data) in downloadData:
+            d = client.downloadPage(self.getURL(url), name)
+            d.addCallback(self._cbDownloadPageTest, data, name)
+            downloads.append(d)
+        return defer.gatherResults(downloads)
+
+    def _cbDownloadPageTest(self, ignored, data, name):
+        with open(name, "rb") as f:
+            bytes = f.read()
+        self.assertEqual(bytes, data)
+
+    def testDownloadPageError1(self):
+        class errorfile:
+            def write(self, data):
+                raise OSError("badness happened during write")
+
+            def close(self):
+                pass
+
+        ef = errorfile()
+        return self.assertFailure(client.downloadPage(self.getURL("file"), ef), IOError)
+
+    def testDownloadPageError2(self):
+        class errorfile:
+            def write(self, data):
+                pass
+
+            def close(self):
+                raise OSError("badness happened during close")
+
+        ef = errorfile()
+        return self.assertFailure(client.downloadPage(self.getURL("file"), ef), IOError)
+
+    def testDownloadPageError3(self):
+        # make sure failures in open() are caught too. This is tricky.
+        # Might only work on posix.
+        open("unwritable", "wb").close()
+        os.chmod("unwritable", 0)  # make it unwritable (to us)
+        d = self.assertFailure(
+            client.downloadPage(self.getURL("file"), "unwritable"), IOError
+        )
+        d.addBoth(self._cleanupDownloadPageError3)
+        return d
+
+    def _cleanupDownloadPageError3(self, ignored):
+        os.chmod("unwritable", 0o700)
+        os.unlink("unwritable")
+        return ignored
+
+    def _downloadTest(self, method):
+        dl = []
+        for (url, code) in [
+            ("nosuchfile", b"404"),
+            ("error", b"401"),
+            ("error?showlength=1", b"401"),
+        ]:
+            d = method(url)
+            d = self.assertFailure(d, error.Error)
+            d.addCallback(lambda exc, code=code: self.assertEqual(exc.args[0], code))
+            dl.append(d)
+        return defer.DeferredList(dl, fireOnOneErrback=True)
+
+    def testServerError(self):
+        return self._downloadTest(lambda url: client.getPage(self.getURL(url)))
+
+    def testDownloadServerError(self):
+        return self._downloadTest(
+            lambda url: client.downloadPage(self.getURL(url), url.split("?")[0])
+        )
+
+    def testFactoryInfo(self):
+        url = self.getURL("file")
+        uri = client.URI.fromBytes(url)
+        factory = client.HTTPClientFactory(url)
+        reactor.connectTCP(nativeString(uri.host), uri.port, factory)
+        return factory.deferred.addCallback(self._cbFactoryInfo, factory)
+
+    def _cbFactoryInfo(self, ignoredResult, factory):
+        self.assertEqual(factory.status, b"200")
+        self.assertTrue(factory.version.startswith(b"HTTP/"))
+        self.assertEqual(factory.message, b"OK")
+        self.assertEqual(factory.response_headers[b"content-length"][0], b"10")
+
+    def test_followRedirect(self):
+        """
+        By default, L{client.getPage} follows redirects and returns the content
+        of the target resource.
+        """
+        d = client.getPage(self.getURL("redirect"))
+        d.addCallback(self.assertEqual, b"0123456789")
+        return d
+
+    def test_noFollowRedirect(self):
+        """
+        If C{followRedirect} is passed a false value, L{client.getPage} does not
+        follow redirects and returns a L{Deferred} which fails with
+        L{error.PageRedirect} when it encounters one.
+        """
+        d = self.assertFailure(
+            client.getPage(self.getURL("redirect"), followRedirect=False),
+            error.PageRedirect,
+        )
+        d.addCallback(self._cbCheckLocation)
+        return d
+
+    def _cbCheckLocation(self, exc):
+        self.assertEqual(exc.location, b"/file")
+
+    def test_infiniteRedirection(self):
+        """
+        When more than C{redirectLimit} HTTP redirects are encountered, the
+        page request fails with L{InfiniteRedirection}.
+        """
+
+        def checkRedirectCount(*a):
+            self.assertEqual(f._redirectCount, 13)
+            self.assertEqual(self.infiniteRedirectResource.count, 13)
+
+        f = client._makeGetterFactory(
+            self.getURL("infiniteRedirect"), client.HTTPClientFactory, redirectLimit=13
+        )
+        d = self.assertFailure(f.deferred, error.InfiniteRedirection)
+        d.addCallback(checkRedirectCount)
+        return d
+
+    def test_isolatedFollowRedirect(self):
+        """
+        C{client.HTTPPagerGetter} instances each obey the C{followRedirect}
+        value passed to the L{client.getPage} call which created them.
+        """
+        d1 = client.getPage(self.getURL("redirect"), followRedirect=True)
+        d2 = client.getPage(self.getURL("redirect"), followRedirect=False)
+
+        d = self.assertFailure(d2, error.PageRedirect).addCallback(lambda dummy: d1)
+        return d
+
+    def test_afterFoundGet(self):
+        """
+        Enabling unsafe redirection behaviour overwrites the method of
+        redirected C{POST} requests with C{GET}.
+        """
+        url = self.getURL("extendedRedirect?code=302")
+        f = client.HTTPClientFactory(url, followRedirect=True, method=b"POST")
+        self.assertFalse(f.afterFoundGet, "By default, afterFoundGet must be disabled")
+
+        def gotPage(page):
+            self.assertEqual(
+                self.extendedRedirect.lastMethod,
+                b"GET",
+                "With afterFoundGet, the HTTP method must change to GET",
+            )
+
+        d = client.getPage(url, followRedirect=True, afterFoundGet=True, method=b"POST")
+        d.addCallback(gotPage)
+        return d
+
+    def test_downloadAfterFoundGet(self):
+        """
+        Passing C{True} for C{afterFoundGet} to L{client.downloadPage} invokes
+        the same kind of redirect handling as passing that argument to
+        L{client.getPage} invokes.
+        """
+        url = self.getURL("extendedRedirect?code=302")
+
+        def gotPage(page):
+            self.assertEqual(
+                self.extendedRedirect.lastMethod,
+                b"GET",
+                "With afterFoundGet, the HTTP method must change to GET",
+            )
+
+        d = client.downloadPage(
+            url, "downloadTemp", followRedirect=True, afterFoundGet=True, method=b"POST"
+        )
+        d.addCallback(gotPage)
+        return d
+
+    def test_afterFoundGetMakesOneRequest(self):
+        """
+        When C{afterFoundGet} is C{True}, L{client.getPage} only issues one
+        request to the server when following the redirect.  This is a regression
+        test, see #4760.
+        """
+
+        def checkRedirectCount(*a):
+            self.assertEqual(self.afterFoundGetCounter.count, 1)
+
+        url = self.getURL("afterFoundGetRedirect")
+        d = client.getPage(url, followRedirect=True, afterFoundGet=True, method=b"POST")
+        d.addCallback(checkRedirectCount)
+        return d
+
+    def test_downloadTimeout(self):
+        """
+        If the timeout indicated by the C{timeout} parameter to
+        L{client.HTTPDownloader.__init__} elapses without the complete response
+        being received, the L{defer.Deferred} returned by
+        L{client.downloadPage} fires with a L{Failure} wrapping a
+        L{defer.TimeoutError}.
+        """
+        self.cleanupServerConnections = 2
+        # Verify the behavior if no bytes are ever written.
+        first = client.downloadPage(self.getURL("wait"), self.mktemp(), timeout=0.01)
+
+        # Verify the behavior if some bytes are written but then the request
+        # never completes.
+        second = client.downloadPage(
+            self.getURL("write-then-wait"), self.mktemp(), timeout=0.01
+        )
+
+        return defer.gatherResults(
+            [
+                self.assertFailure(first, defer.TimeoutError),
+                self.assertFailure(second, defer.TimeoutError),
+            ]
+        )
+
+    def test_downloadTimeoutsWorkWithoutReading(self):
+        """
+        If the timeout indicated by the C{timeout} parameter to
+        L{client.HTTPDownloader.__init__} elapses without the complete response
+        being received, the L{defer.Deferred} returned by
+        L{client.downloadPage} fires with a L{Failure} wrapping a
+        L{defer.TimeoutError}, even if the remote peer isn't reading data from
+        the socket.
+        """
+        self.cleanupServerConnections = 1
+
+        # The timeout here needs to be slightly longer to give the resource a
+        # change to stop the reading.
+        d = client.downloadPage(self.getURL("never-read"), self.mktemp(), timeout=0.05)
+        return self.assertFailure(d, defer.TimeoutError)
+
+    def test_downloadHeaders(self):
+        """
+        After L{client.HTTPDownloader.deferred} fires, the
+        L{client.HTTPDownloader} instance's C{status} and C{response_headers}
+        attributes are populated with the values from the response.
+        """
+
+        def checkHeaders(factory):
+            self.assertEqual(factory.status, b"200")
+            self.assertEqual(factory.response_headers[b"content-type"][0], b"text/html")
+            self.assertEqual(factory.response_headers[b"content-length"][0], b"10")
+            os.unlink(factory.fileName)
+
+        factory = client._makeGetterFactory(
+            self.getURL("file"), client.HTTPDownloader, fileOrName=self.mktemp()
+        )
+        return factory.deferred.addCallback(lambda _: checkHeaders(factory))
+
+    def test_downloadCookies(self):
+        """
+        The C{cookies} dict passed to the L{client.HTTPDownloader}
+        initializer is used to populate the I{Cookie} header included in the
+        request sent to the server.
+        """
+        output = self.mktemp()
+        factory = client._makeGetterFactory(
+            self.getURL("cookiemirror"),
+            client.HTTPDownloader,
+            fileOrName=output,
+            cookies={b"foo": b"bar"},
+        )
+
+        def cbFinished(ignored):
+            self.assertEqual(FilePath(output).getContent(), b"[('foo', 'bar')]")
+
+        factory.deferred.addCallback(cbFinished)
+        return factory.deferred
+
+    def test_downloadRedirectLimit(self):
+        """
+        When more than C{redirectLimit} HTTP redirects are encountered, the
+        page request fails with L{InfiniteRedirection}.
+        """
+
+        def checkRedirectCount(*a):
+            self.assertEqual(f._redirectCount, 7)
+            self.assertEqual(self.infiniteRedirectResource.count, 7)
+
+        f = client._makeGetterFactory(
+            self.getURL("infiniteRedirect"),
+            client.HTTPDownloader,
+            fileOrName=self.mktemp(),
+            redirectLimit=7,
+        )
+        d = self.assertFailure(f.deferred, error.InfiniteRedirection)
+        d.addCallback(checkRedirectCount)
+        return d
+
+    def test_setURL(self):
+        """
+        L{client.HTTPClientFactory.setURL} alters the scheme, host, port and
+        path for absolute URLs.
+        """
+        url = b"http://example.com"
+        f = client.HTTPClientFactory(url)
+        self.assertEqual(
+            (url, b"http", b"example.com", 80, b"/"),
+            (f.url, f.scheme, f.host, f.port, f.path),
+        )
+
+    def test_setURLRemovesFragment(self):
+        """
+        L{client.HTTPClientFactory.setURL} removes the fragment identifier from
+        the path component.
+        """
+        f = client.HTTPClientFactory(b"http://example.com")
+        url = b"https://foo.com:8443/bar;123?a#frag"
+        f.setURL(url)
+        self.assertEqual(
+            (url, b"https", b"foo.com", 8443, b"/bar;123?a"),
+            (f.url, f.scheme, f.host, f.port, f.path),
+        )
+
+    def test_setURLRelativePath(self):
+        """
+        L{client.HTTPClientFactory.setURL} alters the path in a relative URL.
+        """
+        f = client.HTTPClientFactory(b"http://example.com")
+        url = b"/hello"
+        f.setURL(url)
+        self.assertEqual(
+            (url, b"http", b"example.com", 80, b"/hello"),
+            (f.url, f.scheme, f.host, f.port, f.path),
+        )
+
+
+class WebClientSSLTests(WebClientTests):
+
+    if ssl is None or not hasattr(ssl, "DefaultOpenSSLContextFactory"):
+        skip = "OpenSSL not present"
+
+    if not interfaces.IReactorSSL(reactor, None):
+        skip = "Reactor doesn't support SSL"
+
+    def _listen(self, site):
+        return reactor.listenSSL(
+            0,
+            site,
+            contextFactory=ssl.DefaultOpenSSLContextFactory(
+                serverPEMPath, serverPEMPath
+            ),
+            interface="127.0.0.1",
+        )
+
+    def getURL(self, path):
+        return networkString("https://127.0.0.1:%d/%s" % (self.portno, path))
+
+    def testFactoryInfo(self):
+        url = self.getURL("file")
+        uri = client.URI.fromBytes(url)
+        factory = client.HTTPClientFactory(url)
+        reactor.connectSSL(
+            nativeString(uri.host), uri.port, factory, ssl.ClientContextFactory()
+        )
+        # The base class defines _cbFactoryInfo correctly for this
+        return factory.deferred.addCallback(self._cbFactoryInfo, factory)
+
+
+class WebClientRedirectBetweenSSLandPlainTextTests(unittest.TestCase):
+    suppress = [util.suppress(category=DeprecationWarning)]
+
+    if ssl is None or not hasattr(ssl, "DefaultOpenSSLContextFactory"):
+        skip = "OpenSSL not present"
+
+    if not interfaces.IReactorSSL(reactor, None):
+        skip = "Reactor doesn't support SSL"
+
+    def getHTTPS(self, path):
+        return networkString(f"https://127.0.0.1:{self.tlsPortno}/{path}")
+
+    def getHTTP(self, path):
+        return networkString(f"http://127.0.0.1:{self.plainPortno}/{path}")
+
+    def setUp(self):
+        plainRoot = Data(b"not me", "text/plain")
+        tlsRoot = Data(b"me neither", "text/plain")
+
+        plainSite = server.Site(plainRoot, timeout=None)
+        tlsSite = server.Site(tlsRoot, timeout=None)
+
+        self.tlsPort = reactor.listenSSL(
+            0,
+            tlsSite,
+            contextFactory=ssl.DefaultOpenSSLContextFactory(
+                serverPEMPath, serverPEMPath
+            ),
+            interface="127.0.0.1",
+        )
+        self.plainPort = reactor.listenTCP(0, plainSite, interface="127.0.0.1")
+
+        self.plainPortno = self.plainPort.getHost().port
+        self.tlsPortno = self.tlsPort.getHost().port
+
+        plainRoot.putChild(b"one", Redirect(self.getHTTPS("two")))
+        tlsRoot.putChild(b"two", Redirect(self.getHTTP("three")))
+        plainRoot.putChild(b"three", Redirect(self.getHTTPS("four")))
+        tlsRoot.putChild(b"four", Data(b"FOUND IT!", "text/plain"))
+
+    def tearDown(self):
+        ds = list(
+            map(
+                defer.maybeDeferred,
+                [self.plainPort.stopListening, self.tlsPort.stopListening],
+            )
+        )
+        return defer.gatherResults(ds)
+
+    def testHoppingAround(self):
+        return client.getPage(self.getHTTP("one")).addCallback(
+            self.assertEqual, b"FOUND IT!"
+        )
+
+
+class CookieTests(unittest.TestCase):
+    suppress = [util.suppress(category=DeprecationWarning)]
+
+    def _listen(self, site):
+        return reactor.listenTCP(0, site, interface="127.0.0.1")
+
+    def setUp(self):
+        root = Data(b"El toro!", "text/plain")
+        root.putChild(b"cookiemirror", CookieMirrorResource())
+        root.putChild(b"rawcookiemirror", RawCookieMirrorResource())
+        site = server.Site(root, timeout=None)
+        self.port = self._listen(site)
+        self.portno = self.port.getHost().port
+
+    def tearDown(self):
+        return self.port.stopListening()
+
+    def getHTTP(self, path):
+        return networkString("http://127.0.0.1:%d/%s" % (self.portno, path))
+
+    def testNoCookies(self):
+        return client.getPage(self.getHTTP("cookiemirror")).addCallback(
+            self.assertEqual, b"[]"
+        )
+
+    def testSomeCookies(self):
+        cookies = {b"foo": b"bar", b"baz": b"quux"}
+        return client.getPage(
+            self.getHTTP("cookiemirror"), cookies=cookies
+        ).addCallback(self.assertEqual, b"[('baz', 'quux'), ('foo', 'bar')]")
+
+    def testRawNoCookies(self):
+        return client.getPage(self.getHTTP("rawcookiemirror")).addCallback(
+            self.assertEqual, b"None"
+        )
+
+    def testRawSomeCookies(self):
+        cookies = {b"foo": b"bar", b"baz": b"quux"}
+        return client.getPage(
+            self.getHTTP("rawcookiemirror"), cookies=cookies
+        ).addCallback(self.assertIn, (b"'foo=bar; baz=quux'", b"'baz=quux; foo=bar'"))
+
+    def testCookieHeaderParsing(self):
+        factory = client.HTTPClientFactory(b"http://foo.example.com/")
+        proto = factory.buildProtocol("127.42.42.42")
+        transport = StringTransport()
+        proto.makeConnection(transport)
+        for line in [
+            b"200 Ok",
+            b"Squash: yes",
+            b"Hands: stolen",
+            b"Set-Cookie: CUSTOMER=WILE_E_COYOTE; path=/; expires=Wednesday, 09-Nov-99 23:12:40 GMT",
+            b"Set-Cookie: PART_NUMBER=ROCKET_LAUNCHER_0001; path=/",
+            b"Set-Cookie: SHIPPING=FEDEX; path=/foo",
+            b"Set-Cookie: HttpOnly;Secure",
+            b"",
+            b"body",
+            b"more body",
+        ]:
+            proto.dataReceived(line + b"\r\n")
+        self.assertEqual(
+            transport.value(),
+            b"GET / HTTP/1.0\r\n"
+            b"Host: foo.example.com\r\n"
+            b"User-Agent: Twisted PageGetter\r\n"
+            b"\r\n",
+        )
+        self.assertEqual(
+            factory.cookies,
+            {
+                b"CUSTOMER": b"WILE_E_COYOTE",
+                b"PART_NUMBER": b"ROCKET_LAUNCHER_0001",
+                b"SHIPPING": b"FEDEX",
+            },
+        )
+
+
+class HostHeaderTests(unittest.TestCase):
+    """
+    Test that L{HTTPClientFactory} includes the port in the host header
+    if needed.
+    """
+
+    suppress = [util.suppress(category=DeprecationWarning)]
+
+    def _getHost(self, bytes):
+        """
+        Retrieve the value of the I{Host} header from the serialized
+        request given by C{bytes}.
+        """
+        for line in bytes.split(b"\r\n"):
+            try:
+                name, value = line.split(b":", 1)
+                if name.strip().lower() == b"host":
+                    return value.strip()
+            except ValueError:
+                pass
+
+    def test_HTTPDefaultPort(self):
+        """
+        No port should be included in the host header when connecting to the
+        default HTTP port.
+        """
+        factory = client.HTTPClientFactory(b"http://foo.example.com/")
+        proto = factory.buildProtocol(b"127.42.42.42")
+        proto.makeConnection(StringTransport())
+        self.assertEqual(self._getHost(proto.transport.value()), b"foo.example.com")
+
+    def test_HTTPPort80(self):
+        """
+        No port should be included in the host header when connecting to the
+        default HTTP port even if it is in the URL.
+        """
+        factory = client.HTTPClientFactory(b"http://foo.example.com:80/")
+        proto = factory.buildProtocol("127.42.42.42")
+        proto.makeConnection(StringTransport())
+        self.assertEqual(self._getHost(proto.transport.value()), b"foo.example.com")
+
+    def test_HTTPNotPort80(self):
+        """
+        The port should be included in the host header when connecting to the
+        a non default HTTP port.
+        """
+        factory = client.HTTPClientFactory(b"http://foo.example.com:8080/")
+        proto = factory.buildProtocol("127.42.42.42")
+        proto.makeConnection(StringTransport())
+        self.assertEqual(
+            self._getHost(proto.transport.value()), b"foo.example.com:8080"
+        )
+
+    def test_HTTPSDefaultPort(self):
+        """
+        No port should be included in the host header when connecting to the
+        default HTTPS port.
+        """
+        factory = client.HTTPClientFactory(b"https://foo.example.com/")
+        proto = factory.buildProtocol("127.42.42.42")
+        proto.makeConnection(StringTransport())
+        self.assertEqual(self._getHost(proto.transport.value()), b"foo.example.com")
+
+    def test_HTTPSPort443(self):
+        """
+        No port should be included in the host header when connecting to the
+        default HTTPS port even if it is in the URL.
+        """
+        factory = client.HTTPClientFactory(b"https://foo.example.com:443/")
+        proto = factory.buildProtocol("127.42.42.42")
+        proto.makeConnection(StringTransport())
+        self.assertEqual(self._getHost(proto.transport.value()), b"foo.example.com")
+
+    def test_HTTPSNotPort443(self):
+        """
+        The port should be included in the host header when connecting to the
+        a non default HTTPS port.
+        """
+        factory = client.HTTPClientFactory(b"http://foo.example.com:8080/")
+        proto = factory.buildProtocol("127.42.42.42")
+        proto.makeConnection(StringTransport())
+        self.assertEqual(
+            self._getHost(proto.transport.value()), b"foo.example.com:8080"
+        )
+
+
 class URITests:
     """
     Abstract tests for L{twisted.web.client.URI}.
@@ -365,3 +1416,389 @@ class URITestsForIPv6(URITests, unittest.TestCase):
         self.assertEqual(uri.host, b"::1")
         self.assertEqual(uri.netloc, b"[::1]:80")
         self.assertEqual(uri.toBytes(), b"http://[::1]:80/index.html")
+
+
+class DeprecationTests(unittest.TestCase):
+    """
+    Tests that L{client.getPage} and friends are deprecated.
+    """
+
+    def test_getPageDeprecated(self):
+        """
+        L{client.getPage} is deprecated.
+        """
+        port = reactor.listenTCP(
+            0, server.Site(Data(b"", "text/plain")), interface="127.0.0.1"
+        )
+        portno = port.getHost().port
+        self.addCleanup(port.stopListening)
+        url = networkString("http://127.0.0.1:%d" % (portno,))
+
+        d = client.getPage(url)
+        warningInfo = self.flushWarnings([self.test_getPageDeprecated])
+        self.assertEqual(len(warningInfo), 1)
+        self.assertEqual(warningInfo[0]["category"], DeprecationWarning)
+        self.assertEqual(
+            warningInfo[0]["message"],
+            "twisted.web.client.getPage was deprecated in "
+            "Twisted 16.7.0; please use https://pypi.org/project/treq/ or twisted.web.client.Agent instead",
+        )
+
+        return d.addErrback(lambda _: None)
+
+    def test_downloadPageDeprecated(self):
+        """
+        L{client.downloadPage} is deprecated.
+        """
+        port = reactor.listenTCP(
+            0, server.Site(Data(b"", "text/plain")), interface="127.0.0.1"
+        )
+        portno = port.getHost().port
+        self.addCleanup(port.stopListening)
+        url = networkString("http://127.0.0.1:%d" % (portno,))
+
+        path = FilePath(self.mktemp())
+        d = client.downloadPage(url, path.path)
+
+        warningInfo = self.flushWarnings([self.test_downloadPageDeprecated])
+        self.assertEqual(len(warningInfo), 1)
+        self.assertEqual(warningInfo[0]["category"], DeprecationWarning)
+        self.assertEqual(
+            warningInfo[0]["message"],
+            "twisted.web.client.downloadPage was deprecated in "
+            "Twisted 16.7.0; please use https://pypi.org/project/treq/ or twisted.web.client.Agent instead",
+        )
+
+        return d.addErrback(lambda _: None)
+
+    def _testDeprecatedClass(self, klass):
+        """
+        Assert that accessing the given class was deprecated.
+
+        @param klass: The class being deprecated.
+        @type klass: L{str}
+        """
+        getattr(client, klass)
+
+        warningInfo = self.flushWarnings()
+        self.assertEqual(len(warningInfo), 1)
+        self.assertEqual(warningInfo[0]["category"], DeprecationWarning)
+        self.assertEqual(
+            warningInfo[0]["message"],
+            "twisted.web.client.{} was deprecated in "
+            "Twisted 16.7.0: please use https://pypi.org/project/treq/ or twisted.web.client.Agent instead".format(
+                klass
+            ),
+        )
+
+    def test_httpPageGetterDeprecated(self):
+        """
+        L{client.HTTPPageGetter} is deprecated.
+        """
+        self._testDeprecatedClass("HTTPPageGetter")
+
+    def test_httpPageDownloaderDeprecated(self):
+        """
+        L{client.HTTPPageDownloader} is deprecated.
+        """
+        self._testDeprecatedClass("HTTPPageDownloader")
+
+    def test_httpClientFactoryDeprecated(self):
+        """
+        L{client.HTTPClientFactory} is deprecated.
+        """
+        self._testDeprecatedClass("HTTPClientFactory")
+
+    def test_httpDownloaderDeprecated(self):
+        """
+        L{client.HTTPDownloader} is deprecated.
+        """
+        self._testDeprecatedClass("HTTPDownloader")
+
+
+class GetPageMethodInjectionTests(
+    MethodInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Test L{client.getPage} against HTTP method injections.
+    """
+
+    def attemptRequestWithMaliciousMethod(self, method):
+        """
+        Attempt a request with the provided method.
+
+        @param method: see L{MethodInjectionTestsMixin}
+        """
+        uri = b"http://twisted.invalid"
+        client.getPage(uri, method=method)
+
+
+class GetPageURIInjectionTests(
+    URIInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Test L{client.getPage} against URI injections.
+    """
+
+    def attemptRequestWithMaliciousURI(self, uri):
+        """
+        Attempt a request with the provided URI.
+
+        @param uri: see L{URIInjectionTestsMixin}
+        """
+        client.getPage(uri)
+
+
+class DownloadPageMethodInjectionTests(
+    MethodInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Test L{client.getPage} against HTTP method injections.
+    """
+
+    def attemptRequestWithMaliciousMethod(self, method):
+        """
+        Attempt a request with the provided method.
+
+        @param method: see L{MethodInjectionTestsMixin}
+        """
+        uri = b"http://twisted.invalid"
+        client.downloadPage(uri, file=io.BytesIO(), method=method)
+
+
+class DownloadPageURIInjectionTests(
+    URIInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Test L{client.downloadPage} against URI injections.
+    """
+
+    def attemptRequestWithMaliciousURI(self, uri):
+        """
+        Attempt a request with the provided URI.
+
+        @param uri: see L{URIInjectionTestsMixin}
+        """
+        client.downloadPage(uri, file=io.BytesIO())
+
+
+def makeHTTPPageGetterFactory(protocolClass, method, host, path):
+    """
+    Make a L{ClientFactory} that can be used with
+    L{client.HTTPPageGetter} and its subclasses.
+
+    @param protocolClass: The protocol class
+    @type protocolClass: A subclass of L{client.HTTPPageGetter}
+
+    @param method: the HTTP method
+
+    @param host: the host
+
+    @param path: The URI path
+
+    @return: A L{ClientFactory}.
+    """
+    factory = ClientFactory.forProtocol(protocolClass)
+
+    factory.method = method
+    factory.host = host
+    factory.path = path
+
+    factory.scheme = b"http"
+    factory.port = 0
+    factory.headers = {}
+    factory.agent = b"User/Agent"
+    factory.cookies = {}
+
+    return factory
+
+
+class HTTPPageGetterMethodInjectionTests(
+    MethodInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Test L{client.HTTPPageGetter} against HTTP method injections.
+    """
+
+    protocolClass = client.HTTPPageGetter
+
+    def attemptRequestWithMaliciousMethod(self, method):
+        """
+        Attempt a request with the provided method.
+
+        @param method: L{MethodInjectionTestsMixin}
+        """
+        transport = StringTransport()
+        factory = makeHTTPPageGetterFactory(
+            self.protocolClass,
+            method=method,
+            host=b"twisted.invalid",
+            path=b"/",
+        )
+        getter = factory.buildProtocol(
+            address.IPv4Address("TCP", "127.0.0.1", 0),
+        )
+        getter.makeConnection(transport)
+
+
+class HTTPPageGetterURIInjectionTests(
+    URIInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Test L{client.HTTPPageGetter} against HTTP URI injections.
+    """
+
+    protocolClass = client.HTTPPageGetter
+
+    def attemptRequestWithMaliciousURI(self, uri):
+        """
+        Attempt a request with the provided URI.
+
+        @param uri: L{URIInjectionTestsMixin}
+        """
+        transport = StringTransport()
+        # Setting the host and path to the same value is imprecise but
+        # doesn't require parsing an invalid URI.
+        factory = makeHTTPPageGetterFactory(
+            self.protocolClass,
+            method=b"GET",
+            host=uri,
+            path=uri,
+        )
+        getter = factory.buildProtocol(
+            address.IPv4Address("TCP", "127.0.0.1", 0),
+        )
+        getter.makeConnection(transport)
+
+
+class HTTPPageDownloaderMethodInjectionTests(HTTPPageGetterMethodInjectionTests):
+
+    """
+    Test L{client.HTTPPageDownloader} against HTTP method injections.
+    """
+
+    protocolClass = client.HTTPPageDownloader
+
+
+class HTTPPageDownloaderURIInjectionTests(HTTPPageGetterURIInjectionTests):
+    """
+    Test L{client.HTTPPageDownloader} against HTTP URI injections.
+    """
+
+    protocolClass = client.HTTPPageDownloader
+
+
+class HTTPClientFactoryMethodInjectionTests(
+    MethodInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Tests L{client.HTTPClientFactory} against HTTP method injections.
+    """
+
+    def attemptRequestWithMaliciousMethod(self, method):
+        """
+        Attempt a request with the provided method.
+
+        @param method: L{MethodInjectionTestsMixin}
+        """
+        client.HTTPClientFactory(b"https://twisted.invalid", method)
+
+
+class HTTPClientFactoryURIInjectionTests(
+    URIInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Tests L{client.HTTPClientFactory} against HTTP URI injections.
+    """
+
+    def attemptRequestWithMaliciousURI(self, uri):
+        """
+        Attempt a request with the provided URI.
+
+        @param uri: L{URIInjectionTestsMixin}
+        """
+        client.HTTPClientFactory(uri)
+
+
+class HTTPClientFactorySetURLURIInjectionTests(
+    URIInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Tests L{client.HTTPClientFactory.setURL} against HTTP URI injections.
+    """
+
+    def attemptRequestWithMaliciousURI(self, uri):
+        """
+        Attempt a request with the provided URI.
+
+        @param uri: L{URIInjectionTestsMixin}
+        """
+        client.HTTPClientFactory(b"https://twisted.invalid").setURL(uri)
+
+
+class HTTPDownloaderMethodInjectionTests(
+    MethodInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Tests L{client.HTTPDownloader} against HTTP method injections.
+    """
+
+    def attemptRequestWithMaliciousMethod(self, method):
+        """
+        Attempt a request with the provided method.
+
+        @param method: L{MethodInjectionTestsMixin}
+        """
+        client.HTTPDownloader(
+            b"https://twisted.invalid",
+            io.BytesIO(),
+            method=method,
+        )
+
+
+class HTTPDownloaderURIInjectionTests(
+    URIInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Tests L{client.HTTPDownloader} against HTTP URI injections.
+    """
+
+    def attemptRequestWithMaliciousURI(self, uri):
+        """
+        Attempt a request with the provided URI.
+
+        @param uri: L{URIInjectionTestsMixin}
+        """
+        client.HTTPDownloader(uri, io.BytesIO())
+
+
+class HTTPDownloaderSetURLURIInjectionTests(
+    URIInjectionTestsMixin,
+    unittest.SynchronousTestCase,
+):
+    """
+    Tests L{client.HTTPDownloader.setURL} against HTTP URI injections.
+    """
+
+    def attemptRequestWithMaliciousURI(self, uri):
+        """
+        Attempt a request with the provided URI.
+
+        @param uri: L{URIInjectionTestsMixin}
+        """
+        downloader = client.HTTPDownloader(
+            b"https://twisted.invalid",
+            io.BytesIO(),
+        )
+        downloader.setURL(uri)
-- 
2.32.0

